
#--------------------------------------------------------------------------
# Introduction ------------------------------------------------------------
#--------------------------------------------------------------------------
#
# The following script includes the transcriptome and proteome of brain
# endothelial bEnd3 cells treated with 5 uM corticosterone (CORT) or medium
# (MED) for 24 hours.
#
#
#
############################# SECTION 1 ###################################
#
#--------------------------------------------------------------------------
# RNA data: processing and DE ---------------------------------------------
#--------------------------------------------------------------------------

# load libraries ----------------------------------------------------------

require(tidyverse)
require(tximport)
require(rhdf5)
require(DESeq2)
require(vsn)

# Dataset description:
#---------------------

# - CORT treated bEnd3 cells (4 samples)
# - Medium treated bEnd3 cells (4 samples)

# Procedure description:
#-----------------------

# abundance.h files generated by kallisto will be imported into DESeq2 using
# tximport for differential expression (DE) analysis


# generation of a count matrix from kallisto abundance.h files
#--------------------------------------------------------------------------
#
#
# Import transcript abundance estimates from kallisto to DESeq2 using tximport
#
# Resources:
# http://www.bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html
# https://bioconductor.org/packages/devel/bioc/vignettes/tximport/inst/doc/tximport.html


# within the working directory, locate the kallisto output files:

files <- list.files("input/kallisto")

files_list <- file.path(paste0("input/kallisto/", files), "abundance.h5")

file.exists(files_list) # must return "TRUE"

names(files_list) <- c(paste("CORT", 1:4, sep = "_"),
                       paste("MED", 1:4, sep = "_"))

# Transcripts-to-genes convertion:

# import a list of transcripts-to-genes convertions from:
# https://github.com/pachterlab/kallisto-transcriptome-indices/releases
# Download the list for the mouse data (mus_musculus.tar.gz)
# into the working directory and read:

tx2gene <- read.delim("input/transcripts_to_genes.txt", header = FALSE)

colnames(tx2gene) <- c("transcript_ID", "gene_ID", "gene_name")

# estimate gene-level counts:

txi <- tximport(files_list, type = "kallisto", tx2gene = tx2gene)

# save the counts table and the entire object:

write.csv(as.data.frame(txi$counts), "results/gene-level-estimated-counts.csv")

saveRDS(txi, file = "results/tximport_object.rds")


# DE analysis in DESeq2
#--------------------------------------------------------------------------

# create an annotation
# (CORT - corticosterone treatment,
# MED - medium treatment):

sampleTable <- data.frame(condition = factor(rep(c("CORT", "MED"), each = 4),
                                             levels = c("MED", "CORT")))

rownames(sampleTable) <- colnames(txi$counts)

# generate a dds object and perform DE analysis:

ddsTxi <- DESeqDataSetFromTximport(txi,
                                   colData = sampleTable,
                                   design = ~ condition)

dds <- DESeq(ddsTxi)

# generate a results table:

res <- results(dds)


# Adding gene names using the tx2gene file
#--------------------------------------------------------------------------

# add gene IDs as a column and convert the results into a data frame

res$gene_ID <- rownames(res)
res_df <- as.data.frame(res@listData)

# we need only gene ID and gene name columns from the tx2gene file:

gene_names <- tx2gene[, 2:3]

# remove duplicate rows:

gene_names_unique <- unique(gene_names)

# merge by gene ID:

res_annot <- merge(res_df, gene_names_unique, by = "gene_ID")

#--------------------------------------------------------------------------

# (optional) add PR-values (-log10(P-value) x ratio) for simpler ordering:

res_annot <- res_annot %>% mutate(pr = -log10(padj)*log2FoldChange)


# Counts normalization
#--------------------------------------------------------------------------

# normalize the counts using the variance stabilizing transformation:

vsd <- vst(dds, blind = FALSE)

meanSdPlot(assay(vsd))

ggsave("figures/meanSdPlot_vst.pdf",
       units = "cm", width = 12, height = 10)

head(assay(vsd))

# merge results with normalized counts and write:

res_annot$gene_ID <- as.character(res_annot$gene_ID)
res_annot$gene_name <- as.character(res_annot$gene_name)

counts <- as.data.frame(assay(vsd))
counts$gene_ID <- rownames(counts)

res_annot <- merge(res_annot, counts, by = "gene_ID")

head(res_annot)

write.csv(res_annot, "results/DESeq2_results.csv")


#
############################# SECTION 2 ###################################
#
#--------------------------------------------------------------------------
# Protein data: processing and DE -----------------------------------------
#--------------------------------------------------------------------------

# load libraries ----------------------------------------------------------

require(tidyverse)
require(DEP)

# Dataset description:
#---------------------

# - CORT treated bEnd3 cells (5 samples)
# - Medium treated bEnd3 cells (5 samples)

# Procedure description:
#-----------------------

# proteinGroups.txt file containing LFQ intensities (a MaxQuant output)
# will be used for differential expression (DE) analysis in DEP

# DEP tutorial:
# https://bioconductor.org/packages/devel/bioc/vignettes/DEP/inst/doc/DEP.html

#--------------------------------------------------------------------------

# load the data (proteinGroups file and meta data)
# and generate SummarizedExperiment object:

data <- read.delim("input/orbi3623_proteinGroups.txt")
data <- filter(data, Reverse != "+", Potential.contaminant != "+")

data_unique <- make_unique(data, "Gene.names", "Protein.IDs", delim = ";")

LFQ_columns <- grep("LFQ.", colnames(data_unique))

experimental_design <- read.delim("input/orbi3623_exp_design.txt")

experimental_design$label <- as.character(experimental_design$label)
experimental_design$condition <- as.character(experimental_design$condition)

data_se <- make_se(data_unique, LFQ_columns, experimental_design)

# filter out proteins with many missing values
# (all samples but one per group must contain a protein):

data_filt <- filter_missval(data_se, thr = 1)

plot_missval(data_filt)

# normalize using variance stabilizing transformation:

data_norm <- normalize_vsn(data_filt)

# impute missing values:

data_imp <- impute(data_norm, fun = "MinProb", q = 0.01)

# perform DE analysis:

data_diff <- test_diff(data_imp, type = "control", control = "MED")

dep <- add_rejections(data_diff, alpha = 0.05, lfc = log2(1))

res <- get_results(dep)

# remove redundant columns, rename the rest:

res <- res[, c(1,3,4,7)]

colnames(res) <- c("gene_name", "pval", "padj", "log2FoldChange")

# (optional) add PR-values (-log10(P-value) x ratio)
# for simpler ordering:

res <- res %>% mutate(pr = -log10(padj)*log2FoldChange)

# add expression values and merge:

df_wide <- get_df_wide(dep)

df_wide <- df_wide[,1:11]

colnames(df_wide) <- c("gene_name",
                       paste("MED", 1:5, sep = "_"),
                       paste("CORT", 1:5, sep = "_"))

res <- merge(res, df_wide, by = "gene_name")

write.csv(res, "results/orbi3623_results.csv")


#
############################# SECTION 3 ###################################
#
#--------------------------------------------------------------------------
# Over-representation analysis --------------------------------------------
#--------------------------------------------------------------------------

# load libraries ----------------------------------------------------------

require(tidyverse)
require(clusterProfiler)
require(GOSemSim)

# Procedure description:
#-----------------------

# differential expression (DE) results for the bEnd3 cell transcriptome
# and proteome will be used to estimate which biological pathways are
# over-represented amongst DE genes and proteins


# Transcriptome -----------------------------------------------------------
#--------------------------------------------------------------------------

# import the results table:

df <- read.csv("results/DESeq2_results.csv", stringsAsFactors = FALSE)
df <- df[,-1]


# Select differentially expressed genes (DEGs)
#---------------------------------------------

# Filtering criteria:
#--------------------

# average expression level threshold
# (as abundance estimates averaged over all samples)

#
# ---- OPTIONAL ----
#
# Defining the minimal expression threshold:

# mean_thr <- 1
# 
# df_test <- df %>% filter(baseMean > mean_thr)
# 
# p <- ggplot(df_test, aes(x = log10(baseMean + 1))) +
#   geom_histogram(color = "black", fill = "white", binwidth = 0.05) +
#   labs(title = paste0("Mean expression threshold = ", mean_thr),
#        x = "Mean abundance (log10 + 1)", y = "Counts") +
#   theme_classic(base_size = 15)
# 
# ggsave(paste0("figures/", "mean_expr_hist_thr_", mean_thr, ".pdf"),
#        plot = p, device = NULL, units = "cm", width = 12, height = 10)


# the defined expression threshold:
mean_thr <- 100

# BH-adjusted P-value threshold:
padj_thr <- 0.01

# log2-fold change threshold (absolute):
ratio_thr <- log2(1.2)

# filter and prepare a input vector of unique gene names:

df_input <- df %>% filter(baseMean > mean_thr &
                            padj < padj_thr &
                            abs(log2FoldChange) > ratio_thr)

df_input <- df_input[complete.cases(df_input),]
df_input <- as.character(df_input$gene_name)
df_input <- unique(df_input)



# Proteome ----------------------------------------------------------------
#--------------------------------------------------------------------------

# import the results table:

df <- read.csv("results/orbi3623_results.csv", stringsAsFactors = FALSE)
df <- df[,-1]

# Select differentially expressed proteins (DEPs)
#------------------------------------------------

# Filtering criteria:
#--------------------

# BH-adjusted P-value threshold:
padj_thr <- 0.01

# log2-fold change (ratio) threshold (absolute):
ratio_thr <- log2(1.2)


# filter and prepare a input vector of unique gene names (symbols):

df_input <- df %>% filter(padj < padj_thr &
                            abs(log2FoldChange) > ratio_thr)


df_input <- df_input[complete.cases(df_input),]
df_input <- as.character(df_input$gene_name)
df_input <- str_replace(df_input, "\\..+", "")
df_input <- unique(df_input)


#--------------------------------------------------------------------------
# Over-representation analysis (ORA) with clusterProfiler
#--------------------------------------------------------------------------

# ORA with enrichGO function
# (GO terms only, BP subcategory = "Biological Pathways"):

ora_res <- enrichGO(gene = df_input,
                    OrgDb = "org.Mm.eg.db",
                    keyType = "SYMBOL",
                    ont = "BP",
                    pvalueCutoff = 0.05, 
                    qvalueCutoff = 0.10,
                    pAdjustMethod = "BH",
                    minGSSize = 10,
                    maxGSSize = 1000)


dim(ora_res@result)

dotplot(ora_res)

# Reduction of semantic redundancy for significant GO terms
#--------------------------------------------------------------------------

# reduce semantic complexity of GO terms using
# an information content (IC)-based method, the relevance method (Rel),
# with relaxed cut-off level (i.e. less GO terms, more generalized):

# The relevance method: Schlicker et al. 2006 BMC Bioinformatics
# https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-7-302

# compute IC for GO terms of interest:

ic_data <- godata("org.Mm.eg.db", ont="BP", computeIC = TRUE)

# perform the semantic similarity analysis:

sim_cutoff <- 0.5
sim_measure <- "Rel"

ora_res_sim <- simplify(ora_res,
                        semData = ic_data,
                        cutoff = sim_cutoff,
                        by = "p.adjust",
                        select_fun = min,
                        measure = sim_measure)

dotplot(ora_res_sim)

# convert the results into a data frame and
# create separate columns with gene numbers:
# background, gene set, all DEGs, DEGs in a gene set.

ora_res_df <- as.data.frame(ora_res_sim@result)

ora_res_df <- ora_res_df %>%
  separate(GeneRatio, c("DEGs_in_gs","DEGs_total"), sep = "/", convert = TRUE) %>%
  separate(BgRatio, c("gs_size","background"), sep = "/", convert = TRUE) %>%
  dplyr::mutate(gene_ratio = DEGs_in_gs/DEGs_total ) %>%
  dplyr::mutate(bg_ratio = gs_size/background ) %>%
  dplyr::select(-Count)


# ---- OPTIONAL ----

# let us introduce a new parameter - the over-representation factor (ORF) - 
# the gene ratio to the background ratio.
# E.g. for a gene set - 10% among background genes, 30% among DEGs.
# Then the ORF is 30/10 = 3 (fold change).

# ora_res_df <- ora_res_df %>%
#   mutate(orf = gene_ratio/bg_ratio)

# ------------------


# write the results table:

# for transcriptome:
write.csv(ora_res_df, "results/RNA_ORA_GO-BP-sim_results.csv")

# for proteome:
write.csv(ora_res_df, "results/prot_ORA_GO-BP-sim_results.csv")


#
############################# SECTION 4 ###################################
#
#--------------------------------------------------------------------------
# Figures: ORA results ----------------------------------------------------
#--------------------------------------------------------------------------

# load libraries ----------------------------------------------------------

require(tidyverse)

# Procedure description:
#-----------------------

# generate a customized barplot for the ORA results

#--------------------------------------------------------------------------

# load the results:

# for transcriptome:
ora_res_df <- read.csv("results/RNA_ORA_GO-BP-sim_results.csv",
                       stringsAsFactors = FALSE)

# or for proteome:
ora_res_df <- read.csv("results/prot_ORA_GO-BP-sim_results.csv",
                       stringsAsFactors = FALSE)


# select top pathways:

top_path <- 10

ora_res_show <- ora_res_df %>% arrange(p.adjust) %>% head(., top_path)

# plot and save:

upper <- ora_res_show %>%
  dplyr::select(p.adjust) %>%
  head(., 1) %>%
  as.numeric %>%
  -log10(.)

p <- ggplot(ora_res_show, aes(x = reorder(Description, -p.adjust),
                              y = -log10(p.adjust), fill = gene_ratio)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = DEGs_in_gs), hjust = -0.25, size = 3) +
  scale_fill_gradient(low = "blue", high = "red") +
  coord_flip(ylim = c(0, upper + upper*0.2) ) +
  theme_classic() +
  labs(y = "adjusted P-value, -log10") +
  theme(
    axis.title.y = element_blank(),
    axis.title.x = element_text()
  )

p

# for transcriptome:
ggsave("figures/RNA_ORA_GO-BP-sim_barplot.pdf",
       plot = p, device = NULL, units = "cm", width = 16, height = 6)

# for proteome:
ggsave("figures/prot_ORA_GO-BP-sim_barplot.pdf",
       plot = p, device = NULL, units = "cm", width = 16, height = 6)

#
############################# SECTION 5 ###################################
#
#--------------------------------------------------------------------------
# Selection of genes of interest ------------------------------------------
#--------------------------------------------------------------------------

# load libraries ----------------------------------------------------------

require(tidyverse)
require(msigdbr)

# Procedure description:
#-----------------------

# define genes/proteins of interest for further visualization

#--------------------------------------------------------------------------

# Set 1:
#--------------------------------------------------------------------------
# load gene sets related to cell-cell and cell matrix adhesion
#--------------------------------------------------------------------------

go_terms <- c("M8154", "M12087", "M15809")

m_df <- msigdbr(species = "Mus musculus", category = "C5", subcategory = "BP")

go_genes <- filter(as.data.frame(m_df), gs_id %in% go_terms) %>%
  dplyr::select(gene_symbol) %>%
  unlist(.) %>%
  as.vector(.) %>%
  unique(.)


# Set 2:
#--------------------------------------------------------------------------
# load manually selected genes related to endothelial adhesion
# (tight junctions, adherens junctions)
#--------------------------------------------------------------------------

adh_genes <- read.csv("input/candidates.csv",
                         stringsAsFactors = FALSE)

adh_genes <- unique(adh_genes$gene_name)



#
############################# SECTION 6 ###################################
#
#--------------------------------------------------------------------------
# Figures: heatmaps -------------------------------------------------------
#--------------------------------------------------------------------------

# load libraries ----------------------------------------------------------

require(tidyverse)
require(pheatmap)
require(RColorBrewer)
require(grid)


# Procedure description:
#-----------------------

# depict selected genes/proteins of interest on a heatmap

# Note: run SECTION 5 to generate gene sets of interest

#--------------------------------------------------------------------------

# A list of heatmaps (log2FoldChange ordered):

# HM1: RNA, sig, go_genes filtered, adh_genes named

# HM4: prot, sig, no filter, all named

#--------------------------------------------------------------------------

# transcriptome - DE results and counts:

df <- read.csv("results/DESeq2_results.csv", stringsAsFactors = FALSE)
df <- df[,-1]


# proteome - DE results and counts:

df <- read.csv("results/orbi3623_results.csv", stringsAsFactors = FALSE)
df <- df[,-1]

#--------------------------------------------------------------------------

# HM1: RNA, sig, go_genes filtered, adh_genes named
#--------------------------------------------------------------------------

# Pre-select DEGs:

mean_thr <- 100
padj_thr <- 0.01
ratio_thr <- log2(1.2)

de <- df %>% filter(baseMean > mean_thr &
                          padj < padj_thr &
                          abs(log2FoldChange) > ratio_thr)


# filter the genes that belong to the gene set of interest:

de_set <- de %>% filter(gene_name %in% c(go_genes, adh_genes))



# HM2: prot, sig, no filter, all named
#--------------------------------------------------------------------------

# Pre-select DEPs:

padj_thr <- 0.01
ratio_thr <- log2(1.2)

de <- df %>% filter(padj < padj_thr &
                      abs(log2FoldChange) > ratio_thr)


# all DEPs (no additional filtering):

de_set <- de


#--------------------------------------------------------------------------
# Heatmap generation
#--------------------------------------------------------------------------

# reorder the genes according to a preferred metric
# and create a data frame as input for generating a heatmap:

de_set_hm <- de_set %>%
  arrange(desc(log2FoldChange)) %>%
  dplyr::select(gene_name, contains("MED_"), contains("CORT_"))

rownames(de_set_hm) <- de_set_hm$gene_name
de_set_hm <- dplyr::select(de_set_hm, -gene_name)


# Annotations
#--------------------------------------------------------------------------

# (optional) create row annotation:

my_gene_col <- de_set %>% dplyr::select(gene_name, baseMean, log2FoldChange)
my_gene_col$baseMean <- log10(abs(my_gene_col$baseMean))
rownames(my_gene_col) <- my_gene_col$gene_name
my_gene_col <- dplyr::select(my_gene_col, -gene_name)

# create column annotation:

n <- 4 # for transcriptome
n <- 5 # for proteome

my_sample_col <- data.frame(sample = rep(c("CORT", "Medium"), c(n, n)))
rownames(my_sample_col) <- colnames(de_set_hm)
my_sample_col$sample <- factor(my_sample_col$sample, levels = c("Medium", "CORT"))


# specify annotation colors:

# display.brewer.all() # all color palettes

my_annot_colors <- list(sample = c(Medium = "white", CORT = "blue"),
                        baseMean = colorRampPalette(brewer.pal(n = 7, name = "Greens"))(100),
                        log2FoldChange = colorRampPalette(brewer.pal(n = 7, name = "RdYlBu"))(100))

my_heatmap_colors <- colorRampPalette(rev(brewer.pal(n = 7, name = "PuOr")))(100)


p <- pheatmap(de_set_hm,
              color = my_heatmap_colors,
              scale = "row",
              annotation_row = my_gene_col,
              annotation_col = my_sample_col,
              annotation_colors = my_annot_colors,
              clustering_method = "complete",
              cluster_rows = FALSE, cluster_cols = FALSE,
              treeheight_row = 0, treeheight_col = 0,
              show_rownames = TRUE, show_colnames = TRUE,
              display_numbers = FALSE, fontsize_number = 15)


# for HM2 - save the plot:

ggsave(plot = p, "figures/hm2.pdf", units = "cm", width = 12, height = 24)

#--------------------------------------------------------------------------


# for HM1 - label selected genes (rows):

selected_genes <- adh_genes

# load the function add.flag below!

q <- add.flag(p,
              kept.labels = selected_genes,
              repel.degree = 0)


ggsave(plot = q, "figures/hm1.pdf", units = "cm", width = 12, height = 24)



###########################################################################
#
# add.flag function
#
###########################################################################

# Reference:
# Z. Lin: https://stackoverflow.com/users/8449629/z-lin):
# https://stackoverflow.com/questions/52599180/partial-row-labels-heatmap-r

#--------------------------------------------------------------------------

# FUNCTION STARTS

add.flag <- function(pheatmap,
                     kept.labels,
                     repel.degree) {
  
  # repel.degree = number within [0, 1], which controls how much 
  #                space to allocate for repelling labels.
  ## repel.degree = 0: spread out labels over existing range of kept labels
  ## repel.degree = 1: spread out labels over the full y-axis
  
  heatmap <- pheatmap$gtable
  
  new.label <- heatmap$grobs[[which(heatmap$layout$name == "row_names")]] 
  
  # keep only labels in kept.labels, replace the rest with ""
  new.label$label <- ifelse(new.label$label %in% kept.labels, 
                            new.label$label, "")
  
  # calculate evenly spaced out y-axis positions
  repelled.y <- function(d, d.select, k = repel.degree){
    # d = vector of distances for labels
    # d.select = vector of T/F for which labels are significant
    
    # recursive function to get current label positions
    # (note the unit is "npc" for all components of each distance)
    strip.npc <- function(dd){
      if(!"unit.arithmetic" %in% class(dd)) {
        return(as.numeric(dd))
      }
      
      d1 <- strip.npc(dd$arg1)
      d2 <- strip.npc(dd$arg2)
      fn <- dd$fname
      return(lazyeval::lazy_eval(paste(d1, fn, d2)))
    }
    
    full.range <- sapply(seq_along(d), function(i) strip.npc(d[i]))
    selected.range <- sapply(seq_along(d[d.select]), function(i) strip.npc(d[d.select][i]))
    
    return(unit(seq(from = max(selected.range) + k*(max(full.range) - max(selected.range)),
                    to = min(selected.range) - k*(min(selected.range) - min(full.range)), 
                    length.out = sum(d.select)), 
                "npc"))
  }
  new.y.positions <- repelled.y(new.label$y,
                                d.select = new.label$label != "")
  new.flag <- segmentsGrob(x0 = new.label$x,
                           x1 = new.label$x + unit(0.15, "npc"),
                           y0 = new.label$y[new.label$label != ""],
                           y1 = new.y.positions)
  
  # shift position for selected labels
  new.label$x <- new.label$x + unit(0.2, "npc")
  new.label$y[new.label$label != ""] <- new.y.positions
  
  # add flag to heatmap
  heatmap <- gtable::gtable_add_grob(x = heatmap,
                                     grobs = new.flag,
                                     t = 4, 
                                     l = 4
  )
  
  # replace label positions in heatmap
  heatmap$grobs[[which(heatmap$layout$name == "row_names")]] <- new.label
  
  # plot result
  grid.newpage()
  grid.draw(heatmap)
  
  # return a copy of the heatmap invisibly
  invisible(heatmap)
}

# FUNCTION ENDS

###########################################################################



#
############################# SECTION 7 ###################################
#
#--------------------------------------------------------------------------
# Figures: RNA vs protein data --------------------------------------------
#--------------------------------------------------------------------------

# load libraries ----------------------------------------------------------

require(tidyverse)
require(ggrepel)

#--------------------------------------------------------------------------

# Procedure description:
#-----------------------

# plot genes/proteins shared in both datasets and highlight significant ones

#--------------------------------------------------------------------------

# transcriptome - DE results and counts:

rna <- read.csv("results/DESeq2_results.csv", stringsAsFactors = FALSE)
rna <- rna[,-1]
rna <- dplyr::select(rna, log2FoldChange, padj, gene_name)
colnames(rna) <- c("rna_ratio", "rna_padj", "name")


# proteome - DE results and counts:

prot <- read.csv("results/orbi3623_results.csv", stringsAsFactors = FALSE)
prot <- prot[,-1]
prot <- dplyr::select(prot, log2FoldChange, padj, gene_name)
colnames(prot) <- c("prot_ratio", "prot_padj", "name")

# merge nad plot:

shared <- merge(prot, rna, by = "name")

# select DE genes/proteins:

thr <- -log10(0.01) 

selected_genes <- filter(shared, -log10(rna_padj) > thr & -log10(prot_padj) > thr)

p <- ggplot(shared, aes(prot_ratio, rna_ratio)) +
  geom_point(size = 2, color = "grey", alpha = 0.4) +
  geom_point(data = selected_genes,
             color = "red", alpha = 0.6, size = 3) +
  coord_cartesian(xlim = c(-2, 4), ylim = c(-2, 5)) +
  geom_hline(yintercept = 0, size = 0.5, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, size = 0.5, linetype = "dashed", color = "black") +
  geom_text_repel(data = selected_genes,
                   aes(label = name)) +
  labs(x = "mRNA fold change (log2), CORT vs MED", y = "Protein fold change (log2), CORT vs MED") +
  geom_text(x = -1.6, y = -1.6, label = "MED", size = 6) +
  geom_text(x = 3.5, y = 4.3, label = "CORT", size = 6) +
  theme_classic(base_size = 15)


ggsave(plot = p, "figures/rna_vs_prot.pdf", units = "cm", width = 16, height = 16)


###########################################################################
